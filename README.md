# SelfBalancingBinaryTree
Решение тестового задания для компании Syntacore:
Со стандартного ввода приходят ключи (k v, каждый ключ v — это целое число, все ключи разные) и запросы двух видов.

Запрос (m i) на поиск i-го наименьшего элемента (k-ая наименьшая статистика).
Запрос (n j) на поиск количества элементов, меньших, чем заданный j.
Пример:

Вход: k 8 k 2 k -1 m 1 m 2 n 3
Результат: -1 2 2
Ключи могут быть как угодно перемешаны с запросами.

Ваша задача — спроектировать и реализовать класс, представляющий собой расширенное сбалансированное дерево, которое хранило бы ключи и предоставляло интерфейс для выполнения запросов.

Чтобы добиться максимальной эффективности, вы должны продумать такую балансировку дерева, чтобы оба вида запросов работали с логарифмической сложностью (из-за этого ограничения вам скорее всего не подойдут стандартные контейнеры).

Возможные языки реализации - C++, Python или C. Для решения разрешается использовать только средства языка и стандартной библиотеки, без дополнительных пакетов.

Придумайте несколько тестов для проверки вашего решения и реализуйте способ для их запуска в виде консольного приложения. Тестовые данные можно подавать на стандартный ввод из текстового файла.

Бонусные задания:

Попробуйте корректно реализовать конструкторы, деструктор, итераторы для вашего класса.

Предусмотрите возможность сообщить пользователю об ошибках, которые могут быть допущены во входном наборе данных.
## Краткое описание
Мною на языке C++ были реализованы следующие классы:
+ _Node_ - шаблонный узел двоичного девера, содержащий дополнительную информацию о количестве дочерних узлов для текущего узла;
+ _SelfBalancingBinaryTree_ - шаблонное АВЛ-дерево;
+ _BinaryTreeIterator_ - шаблонный итератор двоичного дерева;
+ _RequestHandler_ - обработчик запросов вида (k v), (m i) и (n j);
+ _StatisticOutOfRange_ - исключение, возникающее при неверно заданном параметре i в запросе вида (m i);
+ _NullPointerDereference_ - исключение, возникающее при попытке разыменования пустого итератора.
## Описание процесса сборки и тестирования
Сборка проекта осуществляется с помощью _cmake_, соответствующий файл _CMakeLists.txt_ прилагается.
Для тестирования можно использовать два консольных приложения:
+ _test.o_ - реализует базовые тесты, написанные мною с использования _GoogleTest_;
+ _tree.o_ - реализует обработку вводимых данных из файла или стандартного ввода (для чтения из файла передайте его полный путь в качестве аргумента командной строки)
